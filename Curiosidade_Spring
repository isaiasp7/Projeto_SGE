 1 – **Conflito de configuração entre bancos de produção e teste no Spring Boot**
Ao manter dois bancos de dados distintos — um para o ambiente de execução do sistema (ex.: MySQL) e outro exclusivo para testes (ex.: H2) — é fundamental isolar corretamente os profiles e as propriedades do Spring. Caso contrário, o Spring Boot pode inicializar parcialmente o contexto da aplicação principal antes do contexto de testes.
O problema observado ocorreu porque a propriedade spring.jpa.hibernate.ddl-auto=update estava habilitada. Esse modo não recria o schema, apenas tenta sincronizá-lo, preservando dados existentes. Com isso, ao iniciar os testes, o Hibernate reutilizava metadados e estruturas previamente persistidas, fazendo com que o banco H2 herdasse dados e estruturas do banco principal.
Em termos arquiteturais, houve vazamento de estado entre contextos de persistência, causado pela ausência de isolamento adequado de configuração. O resultado foi a falsa impressão de que o banco de testes estava “buscando” dados do banco principal, quando na verdade o Hibernate apenas não descartava o estado anterior por estar em modo update.

2 – **Quebra de identidade de entidade ao tentar atualizar chave primária no JPA/Hibernate**
No cenário analisado, o CPF foi modelado como chave primária (@Id) da entidade Aluno. Em termos de banco de dados relacional, o MySQL permite a atualização de uma chave primária desde que não haja violação de integridade referencial. Contudo, no contexto de um ORM como o JPA/Hibernate, a chave primária possui um papel adicional: ela define a identidade imutável da entidade dentro do contexto de persistência.
O problema observado surgiu quando, durante um teste, foi realizada a atualização do CPF de um aluno e, em seguida, uma consulta foi executada utilizando o CPF antigo. Esperava-se que a busca retornasse null, indicando que o valor antigo não existia mais. No entanto, o JPA retornava a entidade, mesmo após o update ter sido visualmente confirmado no banco de dados.
    Arquiteturalmente, isso ocorre porque o Hibernate mantém um Persistence Context (cache de primeiro nível), no qual cada entidade é indexada pela sua chave primária no momento em que é carregada. Ao modificar o valor do campo anotado com @Id, cria-se uma inconsistência lógica: o objeto Java passa a conter um novo CPF, mas o contexto de persistência continua associando aquele objeto à chave primária original. Como consequência, consultas subsequentes por findById(cpfAntigo) não acessam o banco de dados, sendo resolvidas diretamente pelo cache, retornando uma entidade que, do ponto de vista do banco, já não deveria existir.
    Em termos conceituais, houve uma violação do contrato de identidade do JPA. O ORM assume que a identidade de uma entidade não muda durante seu ciclo de vida. Quando essa premissa é quebrada, o framework entra em um estado inconsistente, no qual o banco reflete uma realidade e o contexto de persistência reflete outra.